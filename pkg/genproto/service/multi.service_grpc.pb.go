// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.15.8
// source: service/multi.service.proto

package services

import (
	context "context"
	protomulti "github.com/justjack1521/mevium/pkg/genproto/protomulti"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	MeviusMultiService_SessionCreate_FullMethodName      = "/service.MeviusMultiService/SessionCreate"
	MeviusMultiService_SessionEnd_FullMethodName         = "/service.MeviusMultiService/SessionEnd"
	MeviusMultiService_LobbyCreate_FullMethodName        = "/service.MeviusMultiService/LobbyCreate"
	MeviusMultiService_LobbyCancel_FullMethodName        = "/service.MeviusMultiService/LobbyCancel"
	MeviusMultiService_LobbyReady_FullMethodName         = "/service.MeviusMultiService/LobbyReady"
	MeviusMultiService_LobbyStart_FullMethodName         = "/service.MeviusMultiService/LobbyStart"
	MeviusMultiService_LobbyStamp_FullMethodName         = "/service.MeviusMultiService/LobbyStamp"
	MeviusMultiService_LobbySearch_FullMethodName        = "/service.MeviusMultiService/LobbySearch"
	MeviusMultiService_ParticipantJoin_FullMethodName    = "/service.MeviusMultiService/ParticipantJoin"
	MeviusMultiService_ParticipantLeave_FullMethodName   = "/service.MeviusMultiService/ParticipantLeave"
	MeviusMultiService_ParticipantReady_FullMethodName   = "/service.MeviusMultiService/ParticipantReady"
	MeviusMultiService_ParticipantUnready_FullMethodName = "/service.MeviusMultiService/ParticipantUnready"
	MeviusMultiService_ParticipantWatch_FullMethodName   = "/service.MeviusMultiService/ParticipantWatch"
	MeviusMultiService_ParticipantUnwatch_FullMethodName = "/service.MeviusMultiService/ParticipantUnwatch"
	MeviusMultiService_GetGame_FullMethodName            = "/service.MeviusMultiService/GetGame"
	MeviusMultiService_ReadyPlayer_FullMethodName        = "/service.MeviusMultiService/ReadyPlayer"
	MeviusMultiService_EnqueueAction_FullMethodName      = "/service.MeviusMultiService/EnqueueAction"
	MeviusMultiService_DequeueAction_FullMethodName      = "/service.MeviusMultiService/DequeueAction"
	MeviusMultiService_LockAction_FullMethodName         = "/service.MeviusMultiService/LockAction"
)

// MeviusMultiServiceClient is the client API for MeviusMultiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MeviusMultiServiceClient interface {
	SessionCreate(ctx context.Context, in *protomulti.SessionCreateRequest, opts ...grpc.CallOption) (*protomulti.SessionCreateResponse, error)
	SessionEnd(ctx context.Context, in *protomulti.SessionEndRequest, opts ...grpc.CallOption) (*protomulti.SessionEndResponse, error)
	LobbyCreate(ctx context.Context, in *protomulti.LobbyCreateRequest, opts ...grpc.CallOption) (*protomulti.LobbyCreateResponse, error)
	LobbyCancel(ctx context.Context, in *protomulti.LobbyCancelRequest, opts ...grpc.CallOption) (*protomulti.LobbyCancelResponse, error)
	LobbyReady(ctx context.Context, in *protomulti.LobbyStartRequest, opts ...grpc.CallOption) (*protomulti.LobbyStartResponse, error)
	LobbyStart(ctx context.Context, in *protomulti.LobbyStartRequest, opts ...grpc.CallOption) (*protomulti.LobbyStartResponse, error)
	LobbyStamp(ctx context.Context, in *protomulti.LobbyStampRequest, opts ...grpc.CallOption) (*protomulti.LobbyStampResponse, error)
	LobbySearch(ctx context.Context, in *protomulti.LobbySearchRequest, opts ...grpc.CallOption) (*protomulti.LobbySearchResponse, error)
	ParticipantJoin(ctx context.Context, in *protomulti.ParticipantJoinRequest, opts ...grpc.CallOption) (*protomulti.ParticipantJoinResponse, error)
	ParticipantLeave(ctx context.Context, in *protomulti.ParticipantLeaveRequest, opts ...grpc.CallOption) (*protomulti.ParticipantLeaveResponse, error)
	ParticipantReady(ctx context.Context, in *protomulti.ParticipantReadyRequest, opts ...grpc.CallOption) (*protomulti.ParticipantReadyResponse, error)
	ParticipantUnready(ctx context.Context, in *protomulti.ParticipantUnreadyRequest, opts ...grpc.CallOption) (*protomulti.ParticipantUnreadyResponse, error)
	ParticipantWatch(ctx context.Context, in *protomulti.ParticipantWatchRequest, opts ...grpc.CallOption) (*protomulti.ParticipantWatchResponse, error)
	ParticipantUnwatch(ctx context.Context, in *protomulti.ParticipantUnwatchRequest, opts ...grpc.CallOption) (*protomulti.ParticipantUnwatchResponse, error)
	GetGame(ctx context.Context, in *protomulti.GetGameRequest, opts ...grpc.CallOption) (*protomulti.GetGameResponse, error)
	ReadyPlayer(ctx context.Context, in *protomulti.GameReadyPlayerRequest, opts ...grpc.CallOption) (*protomulti.GameReadyPlayerResponse, error)
	EnqueueAction(ctx context.Context, in *protomulti.GameEnqueueActionRequest, opts ...grpc.CallOption) (*protomulti.GameEnqueueActionResponse, error)
	DequeueAction(ctx context.Context, in *protomulti.GameDequeueActionRequest, opts ...grpc.CallOption) (*protomulti.GameDequeueActionResponse, error)
	LockAction(ctx context.Context, in *protomulti.GameLockActionRequest, opts ...grpc.CallOption) (*protomulti.GameLockActionResponse, error)
}

type meviusMultiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMeviusMultiServiceClient(cc grpc.ClientConnInterface) MeviusMultiServiceClient {
	return &meviusMultiServiceClient{cc}
}

func (c *meviusMultiServiceClient) SessionCreate(ctx context.Context, in *protomulti.SessionCreateRequest, opts ...grpc.CallOption) (*protomulti.SessionCreateResponse, error) {
	out := new(protomulti.SessionCreateResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_SessionCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) SessionEnd(ctx context.Context, in *protomulti.SessionEndRequest, opts ...grpc.CallOption) (*protomulti.SessionEndResponse, error) {
	out := new(protomulti.SessionEndResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_SessionEnd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LobbyCreate(ctx context.Context, in *protomulti.LobbyCreateRequest, opts ...grpc.CallOption) (*protomulti.LobbyCreateResponse, error) {
	out := new(protomulti.LobbyCreateResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LobbyCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LobbyCancel(ctx context.Context, in *protomulti.LobbyCancelRequest, opts ...grpc.CallOption) (*protomulti.LobbyCancelResponse, error) {
	out := new(protomulti.LobbyCancelResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LobbyCancel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LobbyReady(ctx context.Context, in *protomulti.LobbyStartRequest, opts ...grpc.CallOption) (*protomulti.LobbyStartResponse, error) {
	out := new(protomulti.LobbyStartResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LobbyReady_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LobbyStart(ctx context.Context, in *protomulti.LobbyStartRequest, opts ...grpc.CallOption) (*protomulti.LobbyStartResponse, error) {
	out := new(protomulti.LobbyStartResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LobbyStart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LobbyStamp(ctx context.Context, in *protomulti.LobbyStampRequest, opts ...grpc.CallOption) (*protomulti.LobbyStampResponse, error) {
	out := new(protomulti.LobbyStampResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LobbyStamp_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LobbySearch(ctx context.Context, in *protomulti.LobbySearchRequest, opts ...grpc.CallOption) (*protomulti.LobbySearchResponse, error) {
	out := new(protomulti.LobbySearchResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LobbySearch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ParticipantJoin(ctx context.Context, in *protomulti.ParticipantJoinRequest, opts ...grpc.CallOption) (*protomulti.ParticipantJoinResponse, error) {
	out := new(protomulti.ParticipantJoinResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ParticipantJoin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ParticipantLeave(ctx context.Context, in *protomulti.ParticipantLeaveRequest, opts ...grpc.CallOption) (*protomulti.ParticipantLeaveResponse, error) {
	out := new(protomulti.ParticipantLeaveResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ParticipantLeave_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ParticipantReady(ctx context.Context, in *protomulti.ParticipantReadyRequest, opts ...grpc.CallOption) (*protomulti.ParticipantReadyResponse, error) {
	out := new(protomulti.ParticipantReadyResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ParticipantReady_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ParticipantUnready(ctx context.Context, in *protomulti.ParticipantUnreadyRequest, opts ...grpc.CallOption) (*protomulti.ParticipantUnreadyResponse, error) {
	out := new(protomulti.ParticipantUnreadyResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ParticipantUnready_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ParticipantWatch(ctx context.Context, in *protomulti.ParticipantWatchRequest, opts ...grpc.CallOption) (*protomulti.ParticipantWatchResponse, error) {
	out := new(protomulti.ParticipantWatchResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ParticipantWatch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ParticipantUnwatch(ctx context.Context, in *protomulti.ParticipantUnwatchRequest, opts ...grpc.CallOption) (*protomulti.ParticipantUnwatchResponse, error) {
	out := new(protomulti.ParticipantUnwatchResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ParticipantUnwatch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) GetGame(ctx context.Context, in *protomulti.GetGameRequest, opts ...grpc.CallOption) (*protomulti.GetGameResponse, error) {
	out := new(protomulti.GetGameResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_GetGame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) ReadyPlayer(ctx context.Context, in *protomulti.GameReadyPlayerRequest, opts ...grpc.CallOption) (*protomulti.GameReadyPlayerResponse, error) {
	out := new(protomulti.GameReadyPlayerResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_ReadyPlayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) EnqueueAction(ctx context.Context, in *protomulti.GameEnqueueActionRequest, opts ...grpc.CallOption) (*protomulti.GameEnqueueActionResponse, error) {
	out := new(protomulti.GameEnqueueActionResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_EnqueueAction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) DequeueAction(ctx context.Context, in *protomulti.GameDequeueActionRequest, opts ...grpc.CallOption) (*protomulti.GameDequeueActionResponse, error) {
	out := new(protomulti.GameDequeueActionResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_DequeueAction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meviusMultiServiceClient) LockAction(ctx context.Context, in *protomulti.GameLockActionRequest, opts ...grpc.CallOption) (*protomulti.GameLockActionResponse, error) {
	out := new(protomulti.GameLockActionResponse)
	err := c.cc.Invoke(ctx, MeviusMultiService_LockAction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeviusMultiServiceServer is the server API for MeviusMultiService service.
// All implementations should embed UnimplementedMeviusMultiServiceServer
// for forward compatibility
type MeviusMultiServiceServer interface {
	SessionCreate(context.Context, *protomulti.SessionCreateRequest) (*protomulti.SessionCreateResponse, error)
	SessionEnd(context.Context, *protomulti.SessionEndRequest) (*protomulti.SessionEndResponse, error)
	LobbyCreate(context.Context, *protomulti.LobbyCreateRequest) (*protomulti.LobbyCreateResponse, error)
	LobbyCancel(context.Context, *protomulti.LobbyCancelRequest) (*protomulti.LobbyCancelResponse, error)
	LobbyReady(context.Context, *protomulti.LobbyStartRequest) (*protomulti.LobbyStartResponse, error)
	LobbyStart(context.Context, *protomulti.LobbyStartRequest) (*protomulti.LobbyStartResponse, error)
	LobbyStamp(context.Context, *protomulti.LobbyStampRequest) (*protomulti.LobbyStampResponse, error)
	LobbySearch(context.Context, *protomulti.LobbySearchRequest) (*protomulti.LobbySearchResponse, error)
	ParticipantJoin(context.Context, *protomulti.ParticipantJoinRequest) (*protomulti.ParticipantJoinResponse, error)
	ParticipantLeave(context.Context, *protomulti.ParticipantLeaveRequest) (*protomulti.ParticipantLeaveResponse, error)
	ParticipantReady(context.Context, *protomulti.ParticipantReadyRequest) (*protomulti.ParticipantReadyResponse, error)
	ParticipantUnready(context.Context, *protomulti.ParticipantUnreadyRequest) (*protomulti.ParticipantUnreadyResponse, error)
	ParticipantWatch(context.Context, *protomulti.ParticipantWatchRequest) (*protomulti.ParticipantWatchResponse, error)
	ParticipantUnwatch(context.Context, *protomulti.ParticipantUnwatchRequest) (*protomulti.ParticipantUnwatchResponse, error)
	GetGame(context.Context, *protomulti.GetGameRequest) (*protomulti.GetGameResponse, error)
	ReadyPlayer(context.Context, *protomulti.GameReadyPlayerRequest) (*protomulti.GameReadyPlayerResponse, error)
	EnqueueAction(context.Context, *protomulti.GameEnqueueActionRequest) (*protomulti.GameEnqueueActionResponse, error)
	DequeueAction(context.Context, *protomulti.GameDequeueActionRequest) (*protomulti.GameDequeueActionResponse, error)
	LockAction(context.Context, *protomulti.GameLockActionRequest) (*protomulti.GameLockActionResponse, error)
}

// UnimplementedMeviusMultiServiceServer should be embedded to have forward compatible implementations.
type UnimplementedMeviusMultiServiceServer struct {
}

func (UnimplementedMeviusMultiServiceServer) SessionCreate(context.Context, *protomulti.SessionCreateRequest) (*protomulti.SessionCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionCreate not implemented")
}
func (UnimplementedMeviusMultiServiceServer) SessionEnd(context.Context, *protomulti.SessionEndRequest) (*protomulti.SessionEndResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionEnd not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LobbyCreate(context.Context, *protomulti.LobbyCreateRequest) (*protomulti.LobbyCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbyCreate not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LobbyCancel(context.Context, *protomulti.LobbyCancelRequest) (*protomulti.LobbyCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbyCancel not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LobbyReady(context.Context, *protomulti.LobbyStartRequest) (*protomulti.LobbyStartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbyReady not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LobbyStart(context.Context, *protomulti.LobbyStartRequest) (*protomulti.LobbyStartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbyStart not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LobbyStamp(context.Context, *protomulti.LobbyStampRequest) (*protomulti.LobbyStampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbyStamp not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LobbySearch(context.Context, *protomulti.LobbySearchRequest) (*protomulti.LobbySearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LobbySearch not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ParticipantJoin(context.Context, *protomulti.ParticipantJoinRequest) (*protomulti.ParticipantJoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantJoin not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ParticipantLeave(context.Context, *protomulti.ParticipantLeaveRequest) (*protomulti.ParticipantLeaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantLeave not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ParticipantReady(context.Context, *protomulti.ParticipantReadyRequest) (*protomulti.ParticipantReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantReady not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ParticipantUnready(context.Context, *protomulti.ParticipantUnreadyRequest) (*protomulti.ParticipantUnreadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantUnready not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ParticipantWatch(context.Context, *protomulti.ParticipantWatchRequest) (*protomulti.ParticipantWatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantWatch not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ParticipantUnwatch(context.Context, *protomulti.ParticipantUnwatchRequest) (*protomulti.ParticipantUnwatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantUnwatch not implemented")
}
func (UnimplementedMeviusMultiServiceServer) GetGame(context.Context, *protomulti.GetGameRequest) (*protomulti.GetGameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGame not implemented")
}
func (UnimplementedMeviusMultiServiceServer) ReadyPlayer(context.Context, *protomulti.GameReadyPlayerRequest) (*protomulti.GameReadyPlayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadyPlayer not implemented")
}
func (UnimplementedMeviusMultiServiceServer) EnqueueAction(context.Context, *protomulti.GameEnqueueActionRequest) (*protomulti.GameEnqueueActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueAction not implemented")
}
func (UnimplementedMeviusMultiServiceServer) DequeueAction(context.Context, *protomulti.GameDequeueActionRequest) (*protomulti.GameDequeueActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DequeueAction not implemented")
}
func (UnimplementedMeviusMultiServiceServer) LockAction(context.Context, *protomulti.GameLockActionRequest) (*protomulti.GameLockActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockAction not implemented")
}

// UnsafeMeviusMultiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeviusMultiServiceServer will
// result in compilation errors.
type UnsafeMeviusMultiServiceServer interface {
	mustEmbedUnimplementedMeviusMultiServiceServer()
}

func RegisterMeviusMultiServiceServer(s grpc.ServiceRegistrar, srv MeviusMultiServiceServer) {
	s.RegisterService(&MeviusMultiService_ServiceDesc, srv)
}

func _MeviusMultiService_SessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.SessionCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).SessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_SessionCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).SessionCreate(ctx, req.(*protomulti.SessionCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_SessionEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.SessionEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).SessionEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_SessionEnd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).SessionEnd(ctx, req.(*protomulti.SessionEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LobbyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.LobbyCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LobbyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LobbyCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LobbyCreate(ctx, req.(*protomulti.LobbyCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LobbyCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.LobbyCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LobbyCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LobbyCancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LobbyCancel(ctx, req.(*protomulti.LobbyCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LobbyReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.LobbyStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LobbyReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LobbyReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LobbyReady(ctx, req.(*protomulti.LobbyStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LobbyStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.LobbyStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LobbyStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LobbyStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LobbyStart(ctx, req.(*protomulti.LobbyStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LobbyStamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.LobbyStampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LobbyStamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LobbyStamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LobbyStamp(ctx, req.(*protomulti.LobbyStampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LobbySearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.LobbySearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LobbySearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LobbySearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LobbySearch(ctx, req.(*protomulti.LobbySearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ParticipantJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.ParticipantJoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ParticipantJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ParticipantJoin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ParticipantJoin(ctx, req.(*protomulti.ParticipantJoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ParticipantLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.ParticipantLeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ParticipantLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ParticipantLeave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ParticipantLeave(ctx, req.(*protomulti.ParticipantLeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ParticipantReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.ParticipantReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ParticipantReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ParticipantReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ParticipantReady(ctx, req.(*protomulti.ParticipantReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ParticipantUnready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.ParticipantUnreadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ParticipantUnready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ParticipantUnready_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ParticipantUnready(ctx, req.(*protomulti.ParticipantUnreadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ParticipantWatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.ParticipantWatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ParticipantWatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ParticipantWatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ParticipantWatch(ctx, req.(*protomulti.ParticipantWatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ParticipantUnwatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.ParticipantUnwatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ParticipantUnwatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ParticipantUnwatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ParticipantUnwatch(ctx, req.(*protomulti.ParticipantUnwatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_GetGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.GetGameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).GetGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_GetGame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).GetGame(ctx, req.(*protomulti.GetGameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_ReadyPlayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.GameReadyPlayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).ReadyPlayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_ReadyPlayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).ReadyPlayer(ctx, req.(*protomulti.GameReadyPlayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_EnqueueAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.GameEnqueueActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).EnqueueAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_EnqueueAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).EnqueueAction(ctx, req.(*protomulti.GameEnqueueActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_DequeueAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.GameDequeueActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).DequeueAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_DequeueAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).DequeueAction(ctx, req.(*protomulti.GameDequeueActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeviusMultiService_LockAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protomulti.GameLockActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeviusMultiServiceServer).LockAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeviusMultiService_LockAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeviusMultiServiceServer).LockAction(ctx, req.(*protomulti.GameLockActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MeviusMultiService_ServiceDesc is the grpc.ServiceDesc for MeviusMultiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MeviusMultiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.MeviusMultiService",
	HandlerType: (*MeviusMultiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SessionCreate",
			Handler:    _MeviusMultiService_SessionCreate_Handler,
		},
		{
			MethodName: "SessionEnd",
			Handler:    _MeviusMultiService_SessionEnd_Handler,
		},
		{
			MethodName: "LobbyCreate",
			Handler:    _MeviusMultiService_LobbyCreate_Handler,
		},
		{
			MethodName: "LobbyCancel",
			Handler:    _MeviusMultiService_LobbyCancel_Handler,
		},
		{
			MethodName: "LobbyReady",
			Handler:    _MeviusMultiService_LobbyReady_Handler,
		},
		{
			MethodName: "LobbyStart",
			Handler:    _MeviusMultiService_LobbyStart_Handler,
		},
		{
			MethodName: "LobbyStamp",
			Handler:    _MeviusMultiService_LobbyStamp_Handler,
		},
		{
			MethodName: "LobbySearch",
			Handler:    _MeviusMultiService_LobbySearch_Handler,
		},
		{
			MethodName: "ParticipantJoin",
			Handler:    _MeviusMultiService_ParticipantJoin_Handler,
		},
		{
			MethodName: "ParticipantLeave",
			Handler:    _MeviusMultiService_ParticipantLeave_Handler,
		},
		{
			MethodName: "ParticipantReady",
			Handler:    _MeviusMultiService_ParticipantReady_Handler,
		},
		{
			MethodName: "ParticipantUnready",
			Handler:    _MeviusMultiService_ParticipantUnready_Handler,
		},
		{
			MethodName: "ParticipantWatch",
			Handler:    _MeviusMultiService_ParticipantWatch_Handler,
		},
		{
			MethodName: "ParticipantUnwatch",
			Handler:    _MeviusMultiService_ParticipantUnwatch_Handler,
		},
		{
			MethodName: "GetGame",
			Handler:    _MeviusMultiService_GetGame_Handler,
		},
		{
			MethodName: "ReadyPlayer",
			Handler:    _MeviusMultiService_ReadyPlayer_Handler,
		},
		{
			MethodName: "EnqueueAction",
			Handler:    _MeviusMultiService_EnqueueAction_Handler,
		},
		{
			MethodName: "DequeueAction",
			Handler:    _MeviusMultiService_DequeueAction_Handler,
		},
		{
			MethodName: "LockAction",
			Handler:    _MeviusMultiService_LockAction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/multi.service.proto",
}
